<!DOCTYPE html>
<html>
<head>
<title> Addison Richards - Vicsek Model </title>
<link rel="stylesheet" type="text/css" href="css/simulations.css">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div class="header">
  <h1> </h1>
</div>

<div class="navbar">
  <a href="index.html">Projects</a>
  <a href="about.html">About Me</a>
  <a href="#">Resume</a>
</div>

<div class="spacer1"> </div>
<div class="row">
  <div class="sideL"></div>
  <div class="main">
    <div class="model">  
      <h2>The Model</h2>
      <p>
        From <a href="https://en.wikipedia.org/wiki/Vicsek_model" target="_blank" style="color: rgb(57, 91, 158); text-decoration: none;">en.wikipedia.org/wiki/Vicsek_model</a>:
      </p>
      <div class="quote">
        <p>
          The Vicsek model is a mathematical model used to describe active matter. 
          One motivation of the study of active matter by physicists is the rich 
          phenomenology associated to this field. Collective motion and swarming 
          are among the most studied phenomena. Within the huge number of models 
          that have been developed to catch such behavior from a microscopic description, 
          the most famous is the model introduced by Tam√°s Vicsek et al. in 1995.[1]
        </p>
        <p>
          Physicists have a great interest in this model as it is minimal and describes 
          a kind of universality. It consists in point-like self-propelled particles that 
          evolve at constant speed and align their velocity with their neighbours' one in 
          presence of noise. Such a model shows collective motion at high density of 
          particles or low noise on the alignment. 
        </p>
      </div>
      <p>
        Each particle is described by a position, <img src="img/Vicsek/math/vec_r.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub>, and a velocity, <img src="img/Vicsek/math/vec_v.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub>.
        Particles always travel at the same velocity, <img src="img/Vicsek/math/v.svg"></img> = |<img src="img/Vicsek/math/vec_v.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub>|, so that the velocity for each particle
        may be written as <img src="img/Vicsek/math/vec_v.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub> = <img src="img/Vicsek/math/v.svg"></img>(<img src="img/Vicsek/math/cos_theta.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub>, 
        <img src="img/Vicsek/math/sin_theta.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub>), where <img src="img/Vicsek/math/theta.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub> gives the direction of motion for each particle and 
        <img src="img/Vicsek/math/v.svg"></img> is a constant.
      </p>
      <p>
        After each time step, the direction of motion for each particle is updated to be the average of all of its 
        neighbours that fall within a cutoff radius, <img src="img/Vicsek/math/r.svg"></img>, plus a uniform random noise variable, 
        <img src="img/Vicsek/math/eta.svg"></img><sub><img src="img/Vicsek/math/i.svg"></img></sub> <img src="img/Vicsek/math/sim_U_eta.svg"></img>.
      </p>
      <p>
        <img src="img/Vicsek/math/r_eq.svg"></img>,  &nbsp; and<br />
        <img src="img/Vicsek/math/theta_eq.svg"></img>
      </p>
      <p>
        When the noise is great enough, the particles will no longer move in a common 
        direction and the average directed velocity of particles will be close to zero. 
        At this point the system is said to have undergone a phase transition from 
        a system with collective motion to a system with randomly moving particles.
      </p>
    </div>
    <div class="data">
      <h2>Data</h2>
      <div class="row2">
        <div class=figure>
          <img src="img/Vicsek/png/v_av.png"></img>
        </div>
        <div class=figure>
          <img src="img/Vicsek/png/v_ts.png"></img>
        </div>
      </div>
    </div>
    <div>
      <h4>Reference</h4>
      <p>[1] arXiv:cond-mat/0611743</p>
    </div>
  </div>
  <div class="sideR">
    <h2>Simulation</h2>
    <div class="simBox">
      <div id="NosSlideContainer">
        <p>Noise: <img src="img/Vicsek/math/eta.svg"></img> = <span id="Nos"></span></p>
        <input type="range" min="0" max="1.6" value="0" step="0.001" class='slider' id="NosRange">
      </div>
      <script>
        var NosSlider = document.getElementById("NosRange");
        var NosOutput = document.getElementById("Nos");
        NosOutput.innerHTML = NosSlider.value;
        NosSlider.oninput = function() {NosOutput.innerHTML = this.value;}
      </script>
      <canvas width = "500" height = "500" id = "c"></canvas>
      <script>
    
        //==================Canvas=========================
        var canvas = document.getElementById('c');
        var gl = canvas.getContext('webgl2');
    
        //==================Shaders========================
        var vertexShaderSource = `#version 300 es
          in vec2 a_position;
          uniform vec2 u_resolution;	
          void main() {
            vec2 zeroToOne = a_position / u_resolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace, 0, 1);
          }
        `;
        
        var fragmentShaderSource = `#version 300 es
          precision mediump float;
          uniform vec4 u_color;
          out vec4 outColor;     
          void main() {
            outColor = u_color;
          }
        `;
    
        function createShader(gl, type, source) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
              return shader;
            }     
          gl.deleteShader(shader);
        }
    
        var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    
        function createProgram(gl, vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
              return program;
            }
            gl.deleteProgram(program);
          }
    
        var program = createProgram(gl, vertexShader, fragmentShader);
        
        //==================Initialization=================
        var positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        var resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
        var colorLocation = gl.getUniformLocation(program, "u_color");
    
        var positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        function setRectangle(gl, x, y, width, height) {
          var x1 = x;
          var x2 = x + width;
          var y1 = y;
          var y2 = y + height;
    
          var positions = [
              x1, y1,
              x2, y1,
              x1, y2,
              x1, y2,
              x2, y1,
              x2, y2
            ];
    
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
        }
    
        var vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionAttributeLocation);
    
        var size = 2;          
        var type = gl.FLOAT;   
        var normalize = false; 
        var stride = 0;        
        var offset = 0;        
        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);
        
        var L = 500;
    
        //==================Functions======================
    
        function pause(milliseconds) {
          const date = Date.now();
          let currentDate = null;
          do { currentDate = Date.now();} 
          while (currentDate - date < milliseconds)
        }
    
        function bird(x, y) {
          this.v = 2.5;
          this.theta = 0.5;
          this.x = x;
          this.y = y;
    
          this.newPos = function(theta) {
            var L = 500;
            this.theta = theta;
            this.x += this.v*Math.cos(this.theta);
            this.y += this.v*Math.sin(this.theta);
            this.x = (this.x + L)%L;
            this.y = (this.y + L)%L;
            setRectangle(gl, this.x, this.y, 6, 6);
            gl.uniform4f(colorLocation, 1, 1, 1, 1);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
          }
        }
    
        var Br = [];
        var BN = 400;
        for(var i=0; i< BN; ++i)
        {
          var xi = Math.floor(Math.random()*L);
          var yi = Math.floor(Math.random()*L);
          Br.push(new bird(xi,yi));
        }
    
        //==================Build Scene====================
        gl.useProgram(program);
        gl.bindVertexArray(vao);
        
        gl.clearColor(0.2, 0.2, 0.2, 0.9);
        
        function render(){
          gl.clearDepth(1.0);
          gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
          gl.viewport(0.0, 0.0, canvas.width, canvas.height);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
          var NosVal = NosSlider.value;
          var Nos = parseFloat(NosVal);
    
          for(var i=0; i< BN; ++i)
          {
            var nbrx_av = 0;
            var nbry_av = 0;
            for(var j=0; j<BN; ++j){
              var Brijx = Br[i].x - Br[j].x;
              var Brijy = Br[i].y - Br[j].y;
              if( (Brijx*Brijx + Brijy*Brijy) < 25*25 )
              {
                nbrx_av += Math.cos(Br[j].theta);
                nbry_av += Math.sin(Br[j].theta);
              }
            }
            var newTheta = Math.atan2(nbry_av,nbrx_av);
            Br[i].newPos((newTheta + Nos*(2*Math.random()-1))%(2*Math.PI));
              
          }
          
          pause(10);
          requestAnimationFrame(render);
        }
        render();
      </script>
    </div>
  </div>
</div>

<div class="spacer1"> </div>
<div class="spacer2"> </div>

<div class="footer">
  <h1> </h1>
</div>

</body>
</html>
